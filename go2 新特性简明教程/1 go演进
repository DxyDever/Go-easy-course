1 go演进

Go语言/golang 诞生于2007年，经过12年的发展，Go逐渐成为了云计算领域新一代的开发语言。Go语言在牺牲很少性能的情况下，语法简洁，功能强大。我是Python的重度用户，在学习Go时，却有一种在学习Python的感觉。并非语法相似，而是Go语言作为一门编译型语言，竟然能够像Python一样，少量的代码就能够完成尽可能多的事情。Go语言仿佛是C和Python的结合体。

Go是如何火起来的呢？我觉得有几个主要的原因，除了语言本身性能好，语法简单，易上手外。Go语言原生支持Goroutine和Channel，极大地降低了并发和异步编程的复杂度。对于服务端编程，并发和异步尤其重要，相比之下，C++，Java等语言的并发和异步控制逻辑过于复杂。另外，杀手级应用Docker的出现起到了很大的推动作用。

Go语言也有很多令人诟病的地方，例如包管理机制，Go直到v1.6才默认开启了vendor机制，vendor机制非常简陋，简单说就是在项目目录下增加一个vendor文件夹，里面放第三方依赖。vendor机制是没有版本概念的，而且不能解决vendor目录嵌套的问题以及同名包函数冲突问题。后来社区涌现了大量的包管理工具，仅官方推荐的包管理工具就有15种之多，应用比较广泛的，如dep、govendor。直到v1.11，官方增加了Go modules机制，才算较为完整地解决了包管理的问题。

Go2 可以说是Go语言一个非常重要的里程碑，Go1 目前虽然已经到了1.12版本，事实上每一个版本很少涉及语法层面的变化，而且每个版本都是向前兼容的。较大的改动如下：

- go1.2切片操作

var a = make([]int, 10)
var b = a[i:j:k]

在旧切片的基础上生成新的切片
newSlice := mslice[2:4:6]	//在mslice的基础上创建新切片newSlice。

有以下三点需要说明：

mslice[i:j:k]这个语句必须满足一个约束，即i<j<=k<=cap(mslice)。
在上面的语句中，newSlice的元素从mslice[2]开始。newSlice的len为4-2=2，cap为6-2=4。mslice[i:j:k]，其计算公式为len=j-i,cap=k-i。
在newSlice或者mslice的cap扩充前，newSlice依旧使用mslice之前使用的底层数组来存储数据。这表明对newSlice进行修改，会影响mslice！反之亦然。什么时候不再相互影响呢？那就是这两个切片的任意一个的cap扩充时，Go会为了给切片分配新的内存，从这一刻起两个切片在内存上才正式脱离共享关系。

- Go1.4 for语言加强
// <= 1.3
for i, v := range x {
    // ...
}

for i := range x {
    // ...
}

// 1.4 新增
var times [5][0]int

for i := 0; i < len(times); i++ {
    // ...
}

for _ = range times {
    // ...
}


- Go1.9 类型别名

type T1 = T2

